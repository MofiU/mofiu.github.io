{"meta":{"title":null,"subtitle":"帅是一种生活态度~","description":null,"author":"Bo","url":"https://mofiu.github.io"},"pages":[{"title":"About","date":"2017-10-25T06:58:11.340Z","updated":"2017-10-25T06:58:11.340Z","comments":true,"path":"about/index.html","permalink":"https://mofiu.github.io/about/index.html","excerpt":"","text":"帅是一种生活态度~"},{"title":"Categories","date":"2017-10-25T06:57:04.441Z","updated":"2017-10-25T06:57:04.441Z","comments":true,"path":"categories/index.html","permalink":"https://mofiu.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-10-25T06:49:53.160Z","updated":"2017-10-25T06:49:53.160Z","comments":true,"path":"tags/index.html","permalink":"https://mofiu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"用Ruby实现自己的DSL","slug":"create-a-ruby-dsl-factory-boy","date":"2017-11-01T08:24:40.000Z","updated":"2017-11-02T04:38:55.524Z","comments":true,"path":"2017/11/01/create-a-ruby-dsl-factory-boy/","link":"","permalink":"https://mofiu.github.io/2017/11/01/create-a-ruby-dsl-factory-boy/","excerpt":"什么是DSL？ DSL(Domain Specific Language) A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains, and lacks specialized features for a particular domain.简而言之，针对某一特定领域，具有受限表达性的一种计算机程序设计语言","text":"什么是DSL？ DSL(Domain Specific Language) A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains, and lacks specialized features for a particular domain.简而言之，针对某一特定领域，具有受限表达性的一种计算机程序设计语言 你可能用到的DSL(Ruby 领域) Rails Routing 1234Rails.application.routes.draw do root 'pages#home' resources :pages, only: [:index, :show]end Rspec 123456789describe Array do describe \"includes_subset?\" do it \"finds subsets\" do a = [1,2,3,4,5] b = [1,2] expect(a.includes_subset?(b)).to eq(true) end endend Rake Tasks 123456namespace :backup do desc \"Backup assets\" task :assets =&gt; :environment do tar_assets endend DB Migrations 123456789class CreateUploads &lt; ActiveRecord::Migration def change create_table :user do |t| t.string :name t.string :email t.timestamps end endend FactoryGirl 123456FactoryGirl.define do factory :user do name 'xiaofang' email 'xiaofang@test.com' endend 怎么用ruby实现DSL 下面我们来给factory_girl找一个男朋友factory_boy 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768require 'active_support/core_ext/string'class User attr_accessor :name, :emailendmodule FactoryBoy @registry = &#123;&#125; def self.registry @registry end class Builder attr_reader :attributes def initialize @attributes = &#123;&#125; end def method_missing(name, *args, &amp;block) @attributes[name] = args[0] end end class Definition def factory(name, &amp;block) builder = Builder.new if block_given? builder.instance_eval(&amp;block) end FactoryBoy.registry[name] = builder end end def self.define(&amp;block) definition = Definition.new definition.instance_eval(&amp;block) if block_given? end def self.build(name, overrides = &#123;&#125;) raise FactoryNotRegistry, \"Factory haven't registry!\" unless @registry.has_key?(name) instance = const_get(name.to_s.classify).new attrs = @registry[name].attributes.merge(overrides) attrs.each do |name, value| instance.send(\"#&#123;name.to_s&#125;=\", value) end instance end class FactoryNotRegistry &lt; StandardError; endendFactoryBoy.define do factory :user do name 'zhangsan' email 'zhangsan@gmail.com' endendp FactoryBoy.registry #=&gt; &#123;:user=&gt;#&lt;FactoryBoy::Builder:0x00000003237b40 @attributes=&#123;:name=&gt;\"zhangsan\", :email=&gt;\"zhangsan@gmail.com\"&#125;&gt;&#125;p FactoryBoy.build(:user) #=&gt; #&lt;User:0x00000003237348 @name=\"zhangsan\", @email=\"zhangsan@gmail.com\"&gt;p FactoryBoy.build(:user, name: 'lisi', email: 'lisi@gmail.com') # =&gt; #&lt;User:0x00000003236e48 @name=\"lisi\", @email=\"lisi@gmail.com\"&gt;p FactoryBoy.build(:other) #=&gt; Factory haven't registry! (FactoryBoy::FactoryNotRegistry) 关键在于理解instance_eval 和 block 利用匿名类创建一个DSL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869module DSL @heros = &#123;&#125; def self.heros @heros end def self.define(&amp;block) hero_builder_class = Class.new do attr_reader :attributes def initialize @attributes = &#123;&#125; end def method_missing(name, *args, &amp;block) @attributes[name] = args[0] end end definition_class = Class.new do define_method :hero do |name, &amp;block| new_hero = hero_builder_class.new new_hero.instance_eval(&amp;block) if block_given? DSL.heros[name] = new_hero end end definition = definition_class.new definition.instance_eval(&amp;block) if block_given? end def self.build_with_template(name, overrides=&#123;&#125;) hero_class = Class.new do attr_accessor *DSL.heros[name].attributes.keys + overrides.keys end instance = hero_class.new DSL.heros[name].attributes.merge(overrides).each do |key, value| instance.instance_variable_set(\"@#&#123;key&#125;\", value) end instance end def self.build(name, attributes=&#123;&#125;) hero_class = Class.new do attr_accessor *attributes.keys end instance = hero_class.new attributes.each do |key, value| instance.instance_variable_set(\"@#&#123;key&#125;\", value) end instance endendDSL.define do hero :lina do name 'lina' age 22 endendp DSL.heros #=&gt; &#123;:lina=&gt;#&lt;#&lt;Class:0x00000002afec98&gt;:0x00000002afe8b0 @attributes=&#123;:name=&gt;\"lina\", :age=&gt;22&#125;&gt;&#125;lina = DSL.build(:lina, intelligence: 18, strength: 13, agility: 15)p lina #=&gt; #&lt;#&lt;Class:0x000000029edea8&gt;:0x000000029ed8b8 @intelligence=18, @strength=13, @agility=15&gt;lina = DSL.build_with_template(:lina, intelligence: 18, strength: 13, agility: 15)p lina #=&gt; #&lt;#&lt;Class:0x00000002bf74d8&gt;:0x00000002bf6c68 @name=\"lina\", @age=22, @intelligence=18, @strength=13, @agility=15&gt;","categories":[{"name":"ruby","slug":"ruby","permalink":"https://mofiu.github.io/categories/ruby/"}],"tags":[{"name":"DSL","slug":"DSL","permalink":"https://mofiu.github.io/tags/DSL/"},{"name":"Rails","slug":"Rails","permalink":"https://mofiu.github.io/tags/Rails/"},{"name":"metaprogram","slug":"metaprogram","permalink":"https://mofiu.github.io/tags/metaprogram/"}]},{"title":"instant_eval和block的区别","slug":"different-between-instant-eval-and-block","date":"2017-11-01T06:16:01.000Z","updated":"2017-11-01T06:36:11.752Z","comments":true,"path":"2017/11/01/different-between-instant-eval-and-block/","link":"","permalink":"https://mofiu.github.io/2017/11/01/different-between-instant-eval-and-block/","excerpt":"","text":"1234567891011121314151617181920class Test attr_accessor :var def say_hello(&amp;block) instance_eval(&amp;block) end def say_hello2(&amp;block) block.call endendTest.new.say_hello do p self #=&gt; main @var = 100endTest.new.say_hello2 do p self #=&gt; #&lt;Test:0x00000002b1e200&gt; @var = 100end 结论： block的作用域是main，instant_eval的作用域是instant本身","categories":[{"name":"ruby","slug":"ruby","permalink":"https://mofiu.github.io/categories/ruby/"}],"tags":[{"name":"作用域","slug":"作用域","permalink":"https://mofiu.github.io/tags/作用域/"},{"name":"instance_eval","slug":"instance-eval","permalink":"https://mofiu.github.io/tags/instance-eval/"},{"name":"block","slug":"block","permalink":"https://mofiu.github.io/tags/block/"}]}]}