{"meta":{"title":null,"subtitle":"帅是一种生活态度~","description":null,"author":"Bo","url":"https://mofiu.github.io"},"pages":[{"title":"About","date":"2017-10-25T06:58:11.340Z","updated":"2017-10-25T06:58:11.340Z","comments":true,"path":"about/index.html","permalink":"https://mofiu.github.io/about/index.html","excerpt":"","text":"帅是一种生活态度~"},{"title":"Tags","date":"2017-10-25T06:49:53.160Z","updated":"2017-10-25T06:49:53.160Z","comments":true,"path":"tags/index.html","permalink":"https://mofiu.github.io/tags/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-10-25T06:57:04.441Z","updated":"2017-10-25T06:57:04.441Z","comments":true,"path":"categories/index.html","permalink":"https://mofiu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Length vs Size vs Count","slug":"Length-vs-Size-vs-Count","date":"2017-11-22T09:28:08.000Z","updated":"2017-11-22T09:50:12.294Z","comments":true,"path":"2017/11/22/Length-vs-Size-vs-Count/","link":"","permalink":"https://mofiu.github.io/2017/11/22/Length-vs-Size-vs-Count/","excerpt":"","text":"原文出处： http://batsov.com/articles/2014/02/17/the-elements-of-style-in-ruby-number-13-length-vs-size-vs-count/ 对新手而言，在ruby中经常会感受到实现一件事可以有好几种方法的体验。比如说，你可以把一堆数字放入一个集合中，比如 Array, Hash, Set等等，你可以通过#length, #size, #count来获取集合的长度, 其中lenght是size的别名。12345678910111213141516arr = [1, 2, 3]arr.length # =&gt; 3arr.size # =&gt; 3arr.count # =&gt; 3h = &#123; a: 1, b: 2 &#125;h.length # =&gt; 2h.size # =&gt; 2h.count # =&gt; 2str = 'name'str.length # =&gt; 4str.size # =&gt; 4# str.count won't work as String does not include Enumerable 我们该用哪个方法呢？让我来昂你做出选择 length不是Enumerable的方法，它是其他具体类的方法，例如String或者Array，它的时间复杂度是O(1)。这个方法的运行速度非常快，使用它准没错。 是使用length还是size是个个人爱好的问题。在获取集合的大小，比如数组(arrays)和哈希(hashs)的时候我比较喜欢用size方法，字符串(string)的时候则用length，因为我觉得一个哈希或者数组没有长度这个概念，而大小(size)比较形象。类似的，一个字符串有长度概念而没有大小概念。而且，length只是size的别名，最后调用的都是同一个方法，所以用那个没没有那么重要。 Enumerable#count是完全不同的一个东西，它经常在用的时候搭配一个代码块或者传入一个参数，比如：1234arr = [1, 1, 2, 3, 5, 6, 8]arr.count(&amp;:even?) # =&gt; 3arr.count(1) # =&gt; 2 你也可以不带参数，它将会返回数组的大小size1arr.count # =&gt; 7 然而它会带来性能影响，为了计算enumerable 的大小，count方法会来回移动，这不是非常高效的方法，特别是对于元素众多的集合。一些类比如Array实现了count的另一个版本(length)，但是也有很多并没有。 你应该避免使用count,尽量用length或者size来替换它。 给Rails开发者的忠告：ActiveRecord::Relation的count和size、length是完全不一样的意义。","categories":[{"name":"ruby","slug":"ruby","permalink":"https://mofiu.github.io/categories/ruby/"}],"tags":[{"name":"style","slug":"style","permalink":"https://mofiu.github.io/tags/style/"}]},{"title":"用Ruby实现自己的DSL","slug":"create-a-ruby-dsl-factory-boy","date":"2017-11-01T08:24:40.000Z","updated":"2017-11-02T04:38:55.524Z","comments":true,"path":"2017/11/01/create-a-ruby-dsl-factory-boy/","link":"","permalink":"https://mofiu.github.io/2017/11/01/create-a-ruby-dsl-factory-boy/","excerpt":"什么是DSL？ DSL(Domain Specific Language) A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains, and lacks specialized features for a particular domain.简而言之，针对某一特定领域，具有受限表达性的一种计算机程序设计语言","text":"什么是DSL？ DSL(Domain Specific Language) A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains, and lacks specialized features for a particular domain.简而言之，针对某一特定领域，具有受限表达性的一种计算机程序设计语言 你可能用到的DSL(Ruby 领域) Rails Routing 1234Rails.application.routes.draw do root 'pages#home' resources :pages, only: [:index, :show]end Rspec 123456789describe Array do describe \"includes_subset?\" do it \"finds subsets\" do a = [1,2,3,4,5] b = [1,2] expect(a.includes_subset?(b)).to eq(true) end endend Rake Tasks 123456namespace :backup do desc \"Backup assets\" task :assets =&gt; :environment do tar_assets endend DB Migrations 123456789class CreateUploads &lt; ActiveRecord::Migration def change create_table :user do |t| t.string :name t.string :email t.timestamps end endend FactoryGirl 123456FactoryGirl.define do factory :user do name 'xiaofang' email 'xiaofang@test.com' endend 怎么用ruby实现DSL 下面我们来给factory_girl找一个男朋友factory_boy 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768require 'active_support/core_ext/string'class User attr_accessor :name, :emailendmodule FactoryBoy @registry = &#123;&#125; def self.registry @registry end class Builder attr_reader :attributes def initialize @attributes = &#123;&#125; end def method_missing(name, *args, &amp;block) @attributes[name] = args[0] end end class Definition def factory(name, &amp;block) builder = Builder.new if block_given? builder.instance_eval(&amp;block) end FactoryBoy.registry[name] = builder end end def self.define(&amp;block) definition = Definition.new definition.instance_eval(&amp;block) if block_given? end def self.build(name, overrides = &#123;&#125;) raise FactoryNotRegistry, \"Factory haven't registry!\" unless @registry.has_key?(name) instance = const_get(name.to_s.classify).new attrs = @registry[name].attributes.merge(overrides) attrs.each do |name, value| instance.send(\"#&#123;name.to_s&#125;=\", value) end instance end class FactoryNotRegistry &lt; StandardError; endendFactoryBoy.define do factory :user do name 'zhangsan' email 'zhangsan@gmail.com' endendp FactoryBoy.registry #=&gt; &#123;:user=&gt;#&lt;FactoryBoy::Builder:0x00000003237b40 @attributes=&#123;:name=&gt;\"zhangsan\", :email=&gt;\"zhangsan@gmail.com\"&#125;&gt;&#125;p FactoryBoy.build(:user) #=&gt; #&lt;User:0x00000003237348 @name=\"zhangsan\", @email=\"zhangsan@gmail.com\"&gt;p FactoryBoy.build(:user, name: 'lisi', email: 'lisi@gmail.com') # =&gt; #&lt;User:0x00000003236e48 @name=\"lisi\", @email=\"lisi@gmail.com\"&gt;p FactoryBoy.build(:other) #=&gt; Factory haven't registry! (FactoryBoy::FactoryNotRegistry) 关键在于理解instance_eval 和 block 利用匿名类创建一个DSL123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869module DSL @heros = &#123;&#125; def self.heros @heros end def self.define(&amp;block) hero_builder_class = Class.new do attr_reader :attributes def initialize @attributes = &#123;&#125; end def method_missing(name, *args, &amp;block) @attributes[name] = args[0] end end definition_class = Class.new do define_method :hero do |name, &amp;block| new_hero = hero_builder_class.new new_hero.instance_eval(&amp;block) if block_given? DSL.heros[name] = new_hero end end definition = definition_class.new definition.instance_eval(&amp;block) if block_given? end def self.build_with_template(name, overrides=&#123;&#125;) hero_class = Class.new do attr_accessor *DSL.heros[name].attributes.keys + overrides.keys end instance = hero_class.new DSL.heros[name].attributes.merge(overrides).each do |key, value| instance.instance_variable_set(\"@#&#123;key&#125;\", value) end instance end def self.build(name, attributes=&#123;&#125;) hero_class = Class.new do attr_accessor *attributes.keys end instance = hero_class.new attributes.each do |key, value| instance.instance_variable_set(\"@#&#123;key&#125;\", value) end instance endendDSL.define do hero :lina do name 'lina' age 22 endendp DSL.heros #=&gt; &#123;:lina=&gt;#&lt;#&lt;Class:0x00000002afec98&gt;:0x00000002afe8b0 @attributes=&#123;:name=&gt;\"lina\", :age=&gt;22&#125;&gt;&#125;lina = DSL.build(:lina, intelligence: 18, strength: 13, agility: 15)p lina #=&gt; #&lt;#&lt;Class:0x000000029edea8&gt;:0x000000029ed8b8 @intelligence=18, @strength=13, @agility=15&gt;lina = DSL.build_with_template(:lina, intelligence: 18, strength: 13, agility: 15)p lina #=&gt; #&lt;#&lt;Class:0x00000002bf74d8&gt;:0x00000002bf6c68 @name=\"lina\", @age=22, @intelligence=18, @strength=13, @agility=15&gt;","categories":[{"name":"ruby","slug":"ruby","permalink":"https://mofiu.github.io/categories/ruby/"}],"tags":[{"name":"DSL","slug":"DSL","permalink":"https://mofiu.github.io/tags/DSL/"},{"name":"Rails","slug":"Rails","permalink":"https://mofiu.github.io/tags/Rails/"},{"name":"metaprogram","slug":"metaprogram","permalink":"https://mofiu.github.io/tags/metaprogram/"}]},{"title":"instant_eval和block的区别","slug":"different-between-instant-eval-and-block","date":"2017-11-01T06:16:01.000Z","updated":"2017-11-01T06:36:11.752Z","comments":true,"path":"2017/11/01/different-between-instant-eval-and-block/","link":"","permalink":"https://mofiu.github.io/2017/11/01/different-between-instant-eval-and-block/","excerpt":"","text":"1234567891011121314151617181920class Test attr_accessor :var def say_hello(&amp;block) instance_eval(&amp;block) end def say_hello2(&amp;block) block.call endendTest.new.say_hello do p self #=&gt; main @var = 100endTest.new.say_hello2 do p self #=&gt; #&lt;Test:0x00000002b1e200&gt; @var = 100end 结论： block的作用域是main，instant_eval的作用域是instant本身","categories":[{"name":"ruby","slug":"ruby","permalink":"https://mofiu.github.io/categories/ruby/"}],"tags":[{"name":"作用域","slug":"作用域","permalink":"https://mofiu.github.io/tags/作用域/"},{"name":"instance_eval","slug":"instance-eval","permalink":"https://mofiu.github.io/tags/instance-eval/"},{"name":"block","slug":"block","permalink":"https://mofiu.github.io/tags/block/"}]}]}